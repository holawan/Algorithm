# 미친로봇

## 문제
통제 할 수 없는 미친 로봇이 평면위에 있다. 그리고 이 로봇은 N번의 행동을 취할 것이다.

각 행동에서 로봇은 4개의 방향 중에 하나를 임의로 선택한다. 그리고 그 방향으로 한 칸 이동한다.

로봇이 같은 곳을 한 번보다 많이 이동하지 않을 때, 로봇의 이동 경로가 단순하다고 한다. (로봇이 시작하는 위치가 처음 방문한 곳이다.) 로봇의 이동 경로가 단순할 확률을 구하는 프로그램을 작성하시오. 예를 들어, EENE와 ENW는 단순하지만, ENWS와 WWWWSNE는 단순하지 않다. (E는 동, W는 서, N은 북, S는 남)

## 입력
첫째 줄에 N, 동쪽으로 이동할 확률, 서쪽으로 이동할 확률, 남쪽으로 이동할 확률, 북쪽으로 이동할 확률이 주어진다. N은 14보다 작거나 같은 자연수이고,  모든 확률은 100보다 작거나 같은 자연수 또는 0이다. 그리고, 동서남북으로 이동할 확률을 모두 더하면 100이다.

확률의 단위는 %이다.

## 출력
첫째 줄에 로봇의 이동 경로가 단순할 확률을 출력한다. 절대/상대 오차는 10-9 까지 허용한다.



### 해결방법

- 로봇이 각 방향마다 갈 수 있는 확률을 정해주고 dr,dc도 마찬가지 순서로 선언해준다.
- 로봇을 중앙에서 출발시키기 위해 로봇이 움직이는 횟수 +1 (2*N+1)을 행 열로 정사각형 지도를 만든다.
- 로봇을 중앙에 위치시킨다.
- DFS를 실행한다
  - 최대 움직임에 도달하면 멈춘다
  - 모든 방향을 돌면서 방문하지 않았고 범위 내이면 진행한다.
  - 방문처리를 진행하고 depth를 1 증가시키며, 현재 방향으로 갈 수 있는 확률을 곱해준다.

```python
def dfs(r, c, depth, p):
    global ans
    # print(p)
    #N번 겹치지 않고 도착했으면 단순한 것 
    #단순할 확률에 추가 
    if depth == N:
        ans += p
        return

    for d in range(4):
        nr, nc = r + dr[d], c + dc[d]

        #방문했던 곳이면 진행x
        if grid[nr][nc]:
            continue
        #범위를 벗어나면 진행 x
        if not 0 <= nr < (2 * N) + 1 or not 0 <= nc < (2 * N) + 1:
            continue
        
        #방문처리 
        grid[nr][nc] = 1
        #새로운 곳이므로 
        #다음 위치로 가서 depth를 추가해주고, 해당 경로로 갈 확률 갱신해주기 
        dfs(nr, nc, depth + 1, p * direction[d] * 0.01)
        #방문취소 처리 
        grid[nr][nc] = 0


N, East,West,North,South = map(int,input().split())
direction = [East, West, North, South]
#동,서,남,북
dr = [0,0,1,-1]
dc = [1,-1,0,0]

grid = [[0]*(2*N+1) for _ in range(2*N+1)]

#로봇은 중앙에서 시작 
grid[N][N] = 1 

ans = 0

dfs(N, N, 0, 1)
print(ans)

```